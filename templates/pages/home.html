{% extends "pages/base.html" %}

{% block content %}

{% include 'pages/_hero.html' %}

{% include 'pages/_finder.html' %}

{% include 'pages/_results.html' %}

{% endblock %}

{% block extra_scripts %}
<script>
(function() {
  // ===== MAP INITIALIZATION =====
  let map, markers;

  try {
    map = L.map('sites-map').setView([39.8283, -98.5795], 4);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    markers = L.markerClusterGroup({
      maxClusterRadius: 20,
      disableClusteringAtZoom: 8,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true
    });
    markers.addTo(map);
  } catch (error) {
    console.error('Failed to initialize map:', error);
  }

  // ===== MAP DATA LOADING =====
  function loadMarkers(geojson) {
    if (!map || !markers) {
      console.warn('Map not initialized, cannot load markers');
      return;
    }

    try {
      markers.clearLayers();

      if (!geojson || !geojson.features || !Array.isArray(geojson.features)) {
        console.warn('Invalid geojson data');
        map.setView([39.8283, -98.5795], 4);
        return;
      }

      if (geojson.features.length === 0) {
        map.setView([39.8283, -98.5795], 4);
        return;
      }

      L.geoJSON(geojson, {
        onEachFeature: function(feature, layer) {
          if (feature.properties && feature.properties.popup) {
            layer.bindPopup(feature.properties.popup);
          }
        }
      }).addTo(markers);

      if (markers.getLayers().length > 0) {
        map.fitBounds(markers.getBounds(), { padding: [50, 50] });
      }
    } catch (error) {
      console.error('Failed to load markers:', error);
      try {
        map.setView([39.8283, -98.5795], 4);
      } catch (e) {
        console.error('Failed to reset map view:', e);
      }
    }
  }

  // Listen for HTMX updates
  document.body.addEventListener('sites:updated', function(event) {
    loadMarkers(event.detail);
  });

  // Load initial data
  setTimeout(function() {
    if (window.sitesGeoJSON) {
      loadMarkers(window.sitesGeoJSON);
    }
  }, 100);

  // ===== FILTER TOGGLE =====
  const toggleBtn = document.getElementById('toggle-filters-btn');
  const filtersPanel = document.getElementById('advanced-filters');
  const showText = toggleBtn.querySelector('.show-text');
  const hideText = toggleBtn.querySelector('.hide-text');

  toggleBtn.addEventListener('click', function() {
    const isHidden = filtersPanel.classList.contains('hidden');

    if (isHidden) {
      filtersPanel.classList.remove('hidden');
      toggleBtn.setAttribute('aria-expanded', 'true');
      showText.classList.add('hidden');
      hideText.classList.remove('hidden');
    } else {
      filtersPanel.classList.add('hidden');
      toggleBtn.setAttribute('aria-expanded', 'false');
      showText.classList.remove('hidden');
      hideText.classList.add('hidden');
    }
  });

  // ===== CLEAR FILTERS BUTTON VISIBILITY =====
  const clearBtn = document.getElementById('clear-filters-btn');
  const searchInput = document.getElementById('search-input');
  const stateFilter = document.getElementById('state-filter');
  const kindFilter = document.getElementById('kind-filter');
  const financeFilter = document.getElementById('finance-filter');

  function updateClearButton() {
    const hasFilters = searchInput.value || stateFilter.value || kindFilter.value || financeFilter.checked;
    clearBtn.style.display = hasFilters ? 'inline-block' : 'none';
  }

  searchInput.addEventListener('input', updateClearButton);
  stateFilter.addEventListener('change', updateClearButton);
  kindFilter.addEventListener('change', updateClearButton);
  financeFilter.addEventListener('change', updateClearButton);
  document.body.addEventListener('htmx:afterSwap', updateClearButton);

  // ===== QUICK-START BUTTONS =====
  const quickStartButtons = document.querySelectorAll('.quick-start-btn');

  quickStartButtons.forEach(function(button) {
    button.addEventListener('click', function() {
      const searchTerm = this.getAttribute('data-search');
      searchInput.value = searchTerm;

      // Trigger HTMX request
      htmx.trigger(searchInput, 'keyup');

      // Scroll to results
      setTimeout(function() {
        document.getElementById('sites-table-container').scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }, 300);
    });
  });

  // ===== GEOLOCATION =====
  const useLocationBtn = document.getElementById('use-location-btn');

  useLocationBtn.addEventListener('click', function() {
    if (!navigator.geolocation) {
      alert('Geolocation is not supported by your browser');
      return;
    }

    // Show loading state
    useLocationBtn.disabled = true;
    useLocationBtn.innerHTML = `
      <svg class="animate-spin h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Finding your location...
    `;

    navigator.geolocation.getCurrentPosition(
      function(position) {
        const userLat = position.coords.latitude;
        const userLng = position.coords.longitude;

        // Find nearest municipalities (this is a simple implementation)
        // In production, you might want a backend endpoint for this
        findNearestMunicipalities(userLat, userLng);
      },
      function(error) {
        console.error('Geolocation error:', error);
        let message = 'Unable to get your location. ';

        switch(error.code) {
          case error.PERMISSION_DENIED:
            message += 'Please allow location access and try again.';
            break;
          case error.POSITION_UNAVAILABLE:
            message += 'Location information is unavailable.';
            break;
          case error.TIMEOUT:
            message += 'Location request timed out.';
            break;
          default:
            message += 'An unknown error occurred.';
        }

        alert(message);
        resetLocationButton();
      },
      {
        timeout: 10000,
        maximumAge: 60000
      }
    );
  });

  function findNearestMunicipalities(userLat, userLng) {
    // Get all sites with coordinates from the current page data
    if (!window.sitesGeoJSON || !window.sitesGeoJSON.features) {
      alert('Unable to find nearby municipalities. Please try searching manually.');
      resetLocationButton();
      return;
    }

    // Calculate distances
    const sitesWithDistance = window.sitesGeoJSON.features
      .filter(f => f.geometry && f.geometry.coordinates)
      .map(function(feature) {
        const [lng, lat] = feature.geometry.coordinates;
        const distance = calculateDistance(userLat, userLng, lat, lng);
        return {
          name: feature.properties.name,
          distance: distance
        };
      })
      .sort((a, b) => a.distance - b.distance)
      .slice(0, 1); // Get closest municipality

    if (sitesWithDistance.length > 0) {
      const nearest = sitesWithDistance[0];
      searchInput.value = nearest.name;
      htmx.trigger(searchInput, 'keyup');

      setTimeout(function() {
        document.getElementById('sites-table-container').scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }, 300);
    } else {
      alert('No municipalities found near your location. Try searching manually.');
    }

    resetLocationButton();
  }

  function calculateDistance(lat1, lon1, lat2, lon2) {
    // Haversine formula for distance between two points
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  function resetLocationButton() {
    useLocationBtn.disabled = false;
    useLocationBtn.innerHTML = `
      <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
      Use My Location
    `;
  }

})();
</script>
{% endblock %}
